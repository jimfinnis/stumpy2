\section{Music}
These components form the largest group, and deal with
actually generating and playing music. This may get split into
subgroups.

\comp{chord}
{Generate a chord, whose notes can be selected and played by
\emph{chordplay} or \emph{noteplay} etc.}
{base:float, select:float}{chord:chord}
This component is used to generate a set of notes -- a chord -- given
a base note and a chord selector.
The output chord is an unordered set of MIDI note values which can
be played by other components.

The base note is a note number where 0 is C4. The chord
has a scale, which is selected by a parameter. There are then four
possible ``chord string'' parameters, which are selected from by
the \emph{select} input. Each string is a number of hex digits,
each of which is an offset into the scale. Thus, the string ``024''
when the scale is ``major'', defines a major triad:
the I chord off the base note. The string ``468'' will define the V
chord, and ``0246'' defines a Vmaj7 chord\footnote{a V7 chord would
require the minor 7th interval, which is not in the scale. I'm working
on ways around this!}.

The \emph{octave} parameter (times 12) is added to the resulting 
notes.
If the \emph{inversions} parameter is true, the new chord is compared with
the previous played chord and the inversion which gives the notes
closest to the previous chord is used.
\startparams
default chord & string & the chord string used when $\lfloor select \rfloor$ is zero or unconnected \\
chord 1 & string & the chord string used when $\lfloor select \rfloor=1$\\
chord 2 & string & the chord string used when $\lfloor select \rfloor=1$\\
chord 3 & string & the chord string used when $\lfloor select \rfloor=1$\\
octave & int & the octave number (0=C4-B$^\#$4)\\
inversions & boolean & if true, use an inversion which makes the notes
as close to the previous chord as possible\\
print & boolean & if true, print the resulting notes to stdout\\
scale & enum & the scale to select the notes from
\end{tabularx}

\clearpage
\comp{chordplay}
{Play all the notes in a chord generated by e.g. the \emph{chord} component.}
{chord:chord, tick:int, velmod:float, durmult:float}{out:flow}
This component takes a chord and plays all its notes to a given MIDI
channel at the same time, or with a short gap between them from low to
high (to give
a rapid arpeggio). The duration of the chord can be specified, the
velocity modified, and the chord transposed.
The chord will start playing when \emph{tick} is non-zero -- this
signal can be generated by a \emph{clock} (p.\pageref{comp:clock}).
The actual velocity is
\[
v = g_{vel} \times \Big(p_{vel}+(p_{velmod}\times in_{velmod})\Big)
\]
and the actual duration is
\[
d = p_{dur} \times in_{durmult} \times 2^{p_{durpow2}}
\]
Note that if the \emph{durmult} input is not connected, its default
value is 1.
\startparams
channel & int & MIDI channel \\
gapsecs & float & gap to leave between subsequent notes in the chord
(low to high) in seconds\\
vel & float & velocity (is multiplied by global velocity)\\
velmod & float & the \emph{vel} input is multiplied by this, then
added to the \emph{vel} parameter.\\
duration & float & base duration (beats)\\
duration-pow2 & float & duration is multiplied by 2 to this power\\
transpose & int & interval in semitones, added to the output note
\end{tabularx}

\clearpage
\comp{noteplay}
{When triggered, plays a note selected from a chord by an input.}
{gate:int, trig:int, note:float, velmod:float, chord:chord, durmult:float}
{out:flow}
When \emph{trig} is nonzero and \emph{gate} is nonzero or unconnected,
this component uses $\lfloor note \rfloor$ to select a note from a chord
and plays it. Typically, the \emph{note}, \emph{trig} and \emph{durmult} inputs
come from a sequencer such as \emph{denseq}.
As with \emph{chordplay}, the velocity and duration are
\[
v = g_{vel} \times \Big(p_{vel}+(p_{velmod}\times in_{velmod})\Big)
\]
and the actual duration is
\[
d = p_{dur} \times in_{durmult} \times 2^{p_{durpow2}}
\]
Note that if the \emph{durmult} input is not connected, its default
value is 1.
\startparams
channel & int & MIDI channel \\
vel & float & velocity (is multiplied by global velocity)\\
velmod & float & the \emph{vel} input is multiplied by this, then
added to the \emph{vel} parameter.\\
duration & float & base duration (beats)\\
duration-pow2 & float & duration is multiplied by 2 to this power\\
transpose & int & interval in semitones, added to the output note
\end{tabularx}

\clearpage
\comp{denseq}{Denary sequencer}
{tick:int}{eventtick:int, value:float, cycletick:int, cyclecount:float,
eventduration:float}
This component uses a string of binary digits to generate numbers
which can be used to control components such as \emph{noteplay}.
The string can also contain gaps (indicated by ``-'' or spaces)
which increase the length of the preceding event.
Each time \emph{tick} is true, the sequencer advances one step.
If this step takes it to a new event, it will
\begin{itemize}
\item set \emph{eventtick} high,
\item set\emph{value} to the digit in the string (0-9),
\item set \emph{cycletick} to high and increment \emph{cyclecount} if
the tick returned us to the beginning,
\item set \emph{eventduration} to the duration of the event (1+the number
of subsequent gaps).
\end{itemize}
The sequencer will loop forever, as long as ticks keep arriving.
Some examples:
\begin{itemize}
\item ``012'' will simply produce the values 0, 1 and 2 with a duration
of 1 on every tick. Every three ticks, \emph{cycletick} will spike high,
and \emph{cyclecount} will increase.
\item ``01 2'' or ``01-2'' will produce the following sequence of outputs:

\begin{tabular}{llllll}
eventtick & value & eventduration & cycletick & cyclecount\\
1 & 0 & 1 & 0 & 0 & event of length 1, output 0\\
1 & 1 & 2 & 0 & 0 & event of length 2, output 1\\
0 & 1 & 2 & 0 & 0 & no event (still doing the previous one)\\
1 & 2 & 1 & 0 & 0 & event of length 1, output 2\\
1 & 0 & 1 & 1 & 1 & cycle repeats\\
1 & 1 & 2 & 0 & 1 & \\
0 & 1 & 2 & 0 & 1 & \\
1 & 2 & 1 & 0 & 1 &
\end{tabular}
\end{itemize}
A typical usage of \emph{denseq} is to wire it to a \emph{noteplay} 
thus:

\begin{tabular}{lll}
denseq & & noteplay\\
\emph{eventtick} & $\to$ & \emph{notetrig} \\
\emph{value} & $\to$ & \emph{note} \\
\emph{eventduration} & $\to$ & \emph{durmult} 
\end{tabular}
\startparams
seq & string & sequence of denary digits and gap characters defining the
output values and durations
\end{tabularx}

